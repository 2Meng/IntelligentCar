clc;clear;
%道路类型判断

IMG_HIGH = 240; 
IMG_WIDTH = 376; 

Image = imread('看到右边了.BMP');

 subplot(2,2,1);
 imshow(Image);
 title('原始图像');
 
 %/* 储存赛道信息 */
midline(IMG_HIGH)   = int16(0);
leftline(IMG_HIGH)    = int16(0);
rightline(IMG_HIGH) = int16(0);


%中线校正前的预处理，用最简单的 左加右除以二
mid = int16(IMG_WIDTH/2);
for i = IMG_HIGH:-1:1
	leftline(i) = 1;
    for j = mid:-1:1       %往左边找
            if Image(i,j) == 0
                leftline(i) = j;
                break
            end
    end

    rightline(i) = IMG_WIDTH;
    for j = mid:IMG_WIDTH   %往右边找
         if Image(i,j) == 0
            rightline(i) = j;
            break
         end  
    end

    mid = uint16((leftline(i)+rightline(i))/2);

    if leftline(i) == rightline(i)
        midline(i) = -1;    %%有效的中线已经寻找结束  中线和边线交点
        
    else
        midline(i) = mid;       
    end
    
end


%第二种做法 ，直接比较摄像头中点和预处理获得的中点。
if midline(100) < int16(IMG_WIDTH/2 - 7)   %比较中间靠略靠上的点
    disp('路靠左，车靠右');
    %选右侧线段判断路的类型
    k1 = rightline(80) - rightline(120);
    k2 = rightline(120) - rightline(160); 
    
else
    if midline(100) > int16(IMG_WIDTH/2 + 7)   %比较中间靠略靠上的点
        disp('路靠右，车靠左');
        k1 = leftline(80) - leftline(120);       
        k2 = leftline(120) - leftline(160);
    else
        disp('车与路正');
        k1 = leftline(80) - leftline(120);       
        k2 = leftline(120) - leftline(160);
    end
end

    deltaK = k1 - k2;
    
   %算出了远像素斜率k1,近像素斜率k2,像素斜率的变化率deltaK
   if deltaK >= -6 && deltaK <= 6
       roadfalg = 1;
       disp('直道');
   else
       disp('弯道');
       if k1 < 0
           roadfalg = 2;
           disp('左弯');
       else
           roadfalg = 2;
           disp('右弯');
       end
   end 